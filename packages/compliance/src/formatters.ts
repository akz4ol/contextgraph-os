/**
 * Report Formatters
 *
 * Export reports to JSON and CSV formats.
 */

import type {
  AuditReport,
  AccessReport,
  DecisionReport,
  ProvenanceReport,
} from './types.js';

/**
 * Format data as JSON
 */
export function formatAsJSON(data: unknown, prettyPrint: boolean = true): string {
  if (prettyPrint) {
    return JSON.stringify(data, null, 2);
  }
  return JSON.stringify(data);
}

/**
 * Format data as CSV
 */
export function formatAsCSV<T extends Record<string, unknown>>(
  data: readonly T[],
  columns?: readonly string[]
): string {
  if (data.length === 0) {
    return '';
  }

  // Get columns from first record if not specified
  const cols = columns ?? Object.keys(data[0]!);

  // Build header
  const header = cols.map((col) => escapeCSVField(col)).join(',');

  // Build rows
  const rows = data.map((record) => {
    return cols
      .map((col) => {
        const value = record[col];
        return escapeCSVField(formatValue(value));
      })
      .join(',');
  });

  return [header, ...rows].join('\n');
}

/**
 * Format an audit report as CSV
 */
export function formatAuditReportAsCSV(report: AuditReport): string {
  const columns = [
    'id',
    'timestamp',
    'agentId',
    'agentName',
    'action',
    'resourceType',
    'resourceId',
    'outcome',
    'reason',
    'duration',
  ];

  return formatAsCSV(report.entries as unknown as Record<string, unknown>[], columns);
}

/**
 * Format an access report as CSV
 */
export function formatAccessReportAsCSV(report: AccessReport): string {
  const columns = [
    'timestamp',
    'subjectId',
    'subjectType',
    'action',
    'resourceType',
    'resourceId',
    'outcome',
    'source',
  ];

  return formatAsCSV(report.entries as unknown as Record<string, unknown>[], columns);
}

/**
 * Format a decision report as CSV
 */
export function formatDecisionReportAsCSV(report: DecisionReport): string {
  const columns = [
    'id',
    'type',
    'title',
    'status',
    'riskLevel',
    'proposedBy',
    'proposedAt',
    'approvedBy',
    'approvedAt',
    'rejectedBy',
    'rejectedAt',
    'executedAt',
    'rationale',
  ];

  return formatAsCSV(report.entries as unknown as Record<string, unknown>[], columns);
}

/**
 * Format a provenance report as CSV
 */
export function formatProvenanceReportAsCSV(report: ProvenanceReport): string {
  const columns = [
    'id',
    'timestamp',
    'sourceType',
    'sourceId',
    'action',
    'entityId',
    'claimId',
    'previousHash',
    'hash',
  ];

  return formatAsCSV(report.entries as unknown as Record<string, unknown>[], columns);
}

/**
 * Format report metadata as a header comment
 */
export function formatMetadataAsComment(
  metadata: {
    reportId: string;
    reportType: string;
    generatedAt: number;
    generatedBy: string;
    totalRecords: number;
  }
): string {
  const lines = [
    `# Report: ${metadata.reportType}`,
    `# Report ID: ${metadata.reportId}`,
    `# Generated: ${new Date(metadata.generatedAt).toISOString()}`,
    `# Generated By: ${metadata.generatedBy}`,
    `# Total Records: ${metadata.totalRecords}`,
    '#',
  ];

  return lines.join('\n');
}

/**
 * Format a value for CSV output
 */
function formatValue(value: unknown): string {
  if (value === null || value === undefined) {
    return '';
  }

  if (typeof value === 'number') {
    return String(value);
  }

  if (typeof value === 'boolean') {
    return value ? 'true' : 'false';
  }

  if (typeof value === 'object') {
    return JSON.stringify(value);
  }

  return String(value);
}

/**
 * Escape a field for CSV
 */
function escapeCSVField(value: string): string {
  // If the value contains comma, newline, or quote, wrap in quotes
  if (value.includes(',') || value.includes('\n') || value.includes('"')) {
    // Escape quotes by doubling them
    return `"${value.replace(/"/g, '""')}"`;
  }

  return value;
}

/**
 * Parse CSV string into records
 */
export function parseCSV<T extends Record<string, unknown>>(csv: string): T[] {
  const lines = csv.split('\n').filter((line) => line.trim() !== '' && !line.startsWith('#'));

  if (lines.length < 2) {
    return [];
  }

  const headers = parseCSVLine(lines[0]!);
  const records: T[] = [];

  for (let i = 1; i < lines.length; i++) {
    const values = parseCSVLine(lines[i]!);
    const record: Record<string, unknown> = {};

    for (let j = 0; j < headers.length; j++) {
      record[headers[j]!] = parseCSVValue(values[j] ?? '');
    }

    records.push(record as T);
  }

  return records;
}

/**
 * Parse a single CSV line
 */
function parseCSVLine(line: string): string[] {
  const values: string[] = [];
  let current = '';
  let inQuotes = false;

  for (let i = 0; i < line.length; i++) {
    const char = line[i]!;

    if (char === '"') {
      if (inQuotes && line[i + 1] === '"') {
        // Escaped quote
        current += '"';
        i++;
      } else {
        // Toggle quotes
        inQuotes = !inQuotes;
      }
    } else if (char === ',' && !inQuotes) {
      values.push(current);
      current = '';
    } else {
      current += char;
    }
  }

  values.push(current);
  return values;
}

/**
 * Parse a CSV value to its appropriate type
 */
function parseCSVValue(value: string): unknown {
  if (value === '') {
    return undefined;
  }

  // Try to parse as number
  const num = Number(value);
  if (!isNaN(num) && value !== '') {
    return num;
  }

  // Try to parse as boolean
  if (value === 'true') return true;
  if (value === 'false') return false;

  // Try to parse as JSON
  if (value.startsWith('{') || value.startsWith('[')) {
    try {
      return JSON.parse(value);
    } catch {
      // Return as string
    }
  }

  return value;
}
